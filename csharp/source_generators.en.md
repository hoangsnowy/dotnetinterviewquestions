# Source Generators & Expression Trees in C#

This guide covers advanced C# features for code generation and expression manipulation.

## Table of Contents
1. [Source Generators](#1-source-generators)
2. [Expression Trees](#2-expression-trees)
3. [Code Generation Patterns](#3-code-generation-patterns)
4. [Performance Considerations](#4-performance-considerations)

## 1. Source Generators

### Question
How do you use source generators in C# to generate code at compile time?

### Suggested Answer
Source generators allow you to generate code during compilation, improving performance and reducing boilerplate.

```csharp
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

[Generator]
public class CustomGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register for syntax notifications
        context.RegisterForSyntaxNotifications(() => new CustomSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get the syntax receiver
        if (context.SyntaxReceiver is not CustomSyntaxReceiver receiver)
            return;

        // Generate code for each class with our attribute
        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var typeSymbol = model.GetDeclaredSymbol(classDeclaration);

            if (typeSymbol == null) continue;

            // Generate code
            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"namespace {typeSymbol.ContainingNamespace}");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine($"    public partial class {typeSymbol.Name}");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine("        public void GeneratedMethod()");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            Console.WriteLine(\"Generated code\");");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            // Add the generated code
            context.AddSource($"{typeSymbol.Name}.g.cs", sourceBuilder.ToString());
        }
    }
}

// Syntax receiver to find candidate classes
public class CustomSyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is ClassDeclarationSyntax classDeclaration)
        {
            // Check if the class has our attribute
            if (classDeclaration.AttributeLists.Any())
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
```

### Follow-up Q&A

1. **Q: When should you use source generators?**
   - **A**: Use source generators when:
     - You need to generate code at compile time
     - You want to reduce runtime overhead
     - You need to analyze existing code
     - You want to avoid reflection

2. **Q: What are the limitations of source generators?**
   - **A**: Source generators:
     - Cannot modify existing code
     - Cannot access runtime information
     - Must be deterministic
     - Cannot use external resources

## 2. Expression Trees

### Question
How do you use expression trees to represent and manipulate code as data?

### Suggested Answer
Expression trees allow you to represent code as data structures that can be analyzed and transformed.

```csharp
using System;
using System.Linq.Expressions;
using System.Reflection;

public class ExpressionTreeExample
{
    public Expression<Func<T, bool>> CreatePropertyEqualsExpression<T>(
        string propertyName,
        object value)
    {
        var parameter = Expression.Parameter(typeof(T), "x");
        var property = Expression.Property(parameter, propertyName);
        var constant = Expression.Constant(value);
        var body = Expression.Equal(property, constant);

        return Expression.Lambda<Func<T, bool>>(body, parameter);
    }

    public Expression<Func<T, object>> CreatePropertySelector<T>(string propertyName)
    {
        var parameter = Expression.Parameter(typeof(T), "x");
        var property = Expression.Property(parameter, propertyName);
        var convert = Expression.Convert(property, typeof(object));

        return Expression.Lambda<Func<T, object>>(convert, parameter);
    }

    public void DemonstrateExpressionTrees()
    {
        // Create a predicate
        var predicate = CreatePropertyEqualsExpression<Product>("Price", 100.00m);
        var products = new List<Product>();
        var filteredProducts = products.AsQueryable().Where(predicate);

        // Create a property selector
        var selector = CreatePropertySelector<Product>("Name");
        var names = products.AsQueryable().Select(selector);
    }
}
```

### Follow-up Q&A

1. **Q: What are the common uses of expression trees?**
   - **A**: Expression trees are commonly used for:
     - LINQ providers
     - Dynamic queries
     - Property access
     - Method calls
     - Validation rules

2. **Q: How do you handle complex expressions?**
   - **A**: Use expression visitors to:
     - Analyze expressions
     - Transform expressions
     - Combine expressions
     - Handle different expression types

## 3. Code Generation Patterns

### Question
What are common patterns for code generation in C#?

### Suggested Answer
Here are some common patterns for code generation using source generators and expression trees.

```csharp
// 1. Property Generation
public class PropertyGenerator
{
    public static string GenerateProperty(string type, string name)
    {
        return $@"
    private {type} _{name};
    public {type} {name}
    {{
        get => _{name};
        set => _{name} = value;
    }}";
    }
}

// 2. Method Generation
public class MethodGenerator
{
    public static string GenerateMethod(
        string returnType,
        string name,
        string[] parameters)
    {
        var paramList = string.Join(", ", parameters);
        return $@"
    public {returnType} {name}({paramList})
    {{
        // Generated method implementation
        return default;
    }}";
    }
}

// 3. Class Generation
public class ClassGenerator
{
    public static string GenerateClass(
        string name,
        string[] properties,
        string[] methods)
    {
        var propertyCode = string.Join("\n", properties);
        var methodCode = string.Join("\n", methods);

        return $@"
public class {name}
{{
    {propertyCode}
    {methodCode}
}}";
    }
}
```

### Follow-up Q&A

1. **Q: How do you handle dependencies in generated code?**
   - **A**: 
     - Use partial classes
     - Generate interfaces
     - Use dependency injection
     - Handle circular dependencies

2. **Q: How do you test generated code?**
   - **A**: 
     - Test the generator
     - Test the generated code
     - Use integration tests
     - Verify compilation

## 4. Performance Considerations

### Question
How do you optimize code generation and expression trees for performance?

### Suggested Answer
Here are key considerations for optimizing code generation and expression trees.

```csharp
public class OptimizedExpressionTree
{
    private readonly ConcurrentDictionary<string, Delegate> _cache = new();

    public Func<T, bool> CompilePredicate<T>(Expression<Func<T, bool>> expression)
    {
        var key = expression.ToString();
        return (Func<T, bool>)_cache.GetOrAdd(key, _ => expression.Compile());
    }

    public void DemonstrateOptimization()
    {
        // Cache compiled expressions
        var predicate = CompilePredicate<Product>(p => p.Price > 100.00m);
        var products = new List<Product>();
        var filteredProducts = products.Where(predicate);

        // Use expression visitors for complex transformations
        var visitor = new CustomExpressionVisitor();
        var transformed = visitor.Visit(predicate);
    }
}

public class CustomExpressionVisitor : ExpressionVisitor
{
    protected override Expression VisitBinary(BinaryExpression node)
    {
        // Optimize binary expressions
        if (node.NodeType == ExpressionType.Equal)
        {
            // Handle equality comparison
        }
        return base.VisitBinary(node);
    }
}
```

### Follow-up Q&A

1. **Q: How do you handle memory usage in code generation?**
   - **A**: 
     - Cache generated code
     - Use string builders
     - Implement cleanup
     - Monitor memory usage

2. **Q: What are the performance implications of expression trees?**
   - **A**: 
     - Compilation overhead
     - Memory usage
     - Execution speed
     - Cache management

## Additional Resources

- [Microsoft Docs: Source Generators](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)
- [Microsoft Docs: Expression Trees](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/)
- [Microsoft Docs: Code Generation](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)
- [Microsoft Docs: Performance](https://docs.microsoft.com/en-us/dotnet/framework/performance/) 